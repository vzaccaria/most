# Introduction

This manual describes how it is possible to integrate simulators into the
evaluation chain of **MOST** by means of the Multicube XML Interface. Simulators
should be integrated by:

- defining the design space by writing an appropriate design space definition
  XML file.

- making them receive the parameters value through an appropriate XML file
  (generated by the **MOST** XML driver). Making them write the output values on
  an appropriate XML output file (read back by the **MOST** XML driver).

# MOST XML Design Space Definition

The definition of the design space is done by using an XML file that is composed
of a preamble, which defines the namespace and supported version. **MOST**
supports both versions 1.3 and 1.4.

    <?xml version="1.0" encoding="UTF-8"?>
    	<design_space xmlns="http://www.multicube.eu/" version="1.4">
    		<simulator>	...	</simulator>
    		<parameters>	...	</parameters>
    		<system_metrics>	...	</system_metrics>
    		<rules>	...	</rules>
    	</design_space>

The remaining part of the file describes the simulator invocation method
(**simulator** marker), the set of parameters of the simulator which can be
configured (**parameters** marker), the system metrics which can be estimated by
the simulator (**system_metrics** marker) and the rules to generate feasible
configurations.

## Simulator Invocation

The **simulator_executable** marker is used for specifying the complete path
name of the executable:

     <simulator>
    	<simulator_executable path="/path/my_simulator_executable" />

 	 </simulator>

The path is specified by using Unix conventions. The simulator executable is
invoked with three arguments:

    my_simulator_executable \
    	--xml_system_configuration=sc_path_name \
    	--xml_system_metrics=sm_path_name \
    	--reference_xsd=xsd_file_name \
    	--timeout=nsec

where **sc_path_name** is the path name of XML file describing the system
configuration to be passed to the simulator. The **sm_path_name** is the path
name of the output XML file which should be used by the simulator for producing
the system metrics output.

The argument **--reference_xsd=xsd_file_name** is used for specifying the
position of the reference simulator interface XSD file in the file system. This
argument can be used by the simulator for validating the input and output files
exchanged with **MOST**.

**[R1.5]**. The **--timeout** option has been added in revision 1.4+. Whenever
this option is specified, the simulator should kill all its processes in
**nsec** seconds. This option is not mandatory, thus the simulator should also
work if this is not specified. This option should not generate necessarily a
timeout error, i.e., the simulator can stop and produce a valid output metric
file at the end.

## Parameters definition

The **parameters** marker is used by the use case and simulator provider to
specify the names, the types and the ranges of the parameters that can be
explored by the DSE tool. The section contains a list of **parameter** markers:

    <parameters>
    	<parameter name="seed" description="RNG seed" type="integer" min="0" max="10"/>
    	<parameter name="fetch_queue" description="..." type="integer" min="1" max="8" step="2"/>
    </parameters >

For each parameter a unique name must be provided. This name will be used for
generating configurations at the input of the simulator. Feasible parameter
names are identified by the following regular expression:

    [A-Za-z_] [A-Za-z0-9_]*

The parameters types can be divided into two categories:

- Scalar types
- Variable vector types

### Scalar parameter types

The scalar parameter type can be:

- **integer and boolean**. The integer type specifies a simple sequential
  integer progression associated that specific parameter. The min and max
  attributes (which are mandatory) specify the boundaries of the progression.
  The step attribute can be used to produce non-unitary progressions. The
  Boolean type is an integer progression with min=0 and max=1.

- **exp2**. The values associated with an "exp2" parameter type should be
  computed by **MOST** by using a power of two progression. For example:

      		<parameter name="il1_block_sz_bytes" description="..." type="exp2" min="8" max="64"/>

  will be interpreted by **MOST** as a parameter with range values: { "8", "16",
  "32", "64" }

- **string**. The values can be specified with an enumeration:

      		<parameter name="bpred" description="branch predictor type" type="string">
      			<item value="nottaken"/>
      			<item value="taken"/>
      			<item value="perfect"/>
      			<item value="bimod"/>
      			<item value="2lev"/>
      			<item value="comb"/>
      		</parameter >

When the design space is composed of a subset of scalar parameters each one with
the same type and range, the design space definition can be represented in a
more compact way by adding an integer attribute instances, instead of declaring
one line for each scalar parameter. If the attribute is not declared it is
considered equal to 1.

### Variable Vector Types

The following types are introduced for producing variable vector types with
specific constraints on the possible combinations of the components:

- **on-off mask**. The on-off mask is essentially a vector combination of
  boolean values with a specific dimension. We use the on_set_size attribute to
  specify the amount of elements which should be "on" in the resulting vector:

      		<parameter type="on_off_mask"
      			   name="active_processors"
      			   dimension="7"
      			   on_set_size="@number_of_threads" />

  The on*set_size can be a fixed value or a reference to a variable value. In
  the case of reference to variable values, the notation @parameter should be
  used. For example the notation @number_of_threads indicates that the
  "on_set_size" should be equal to the "number_of_threads" parameter of the
  configuration under evaluation. In this example we assume that the
  "number_of_threads" parameter type is an integer progression without explicit
  steps; as a matter of fact the notation @\_parameter* can refer only to
  integer parameters with a step=1. When the on_set_size attribute is not
  specified, all the possible combinations of the Boolean vector are considered
  in the generation of the associated progression. The dimension of the
  on_off_mask can be variable as well:

    	<parameter type="on_off_mask" name="QoS_priorities" dimension="@number_of_threads" />

  The previous parameter specification contains, as an example, the Boolean QoS
  priorities for each of the active nodes of a target multi-processor system.

- **Permutation**. Permutations are useful for specifying combinatorial
  problems. In this case a task identifier should be generated for each active
  processor:

        <parameter type="permutation" name="thread_assignment" dimension="@number_of_threads" />

  A permutation contains a non-repeatable sequence of values from 1 to the
  actual dimension of the vector. For example, the variable vector parameter:

    	<parameter type="permutation" name="example" dimension="2" />

  can assume the following values [1,2] or [2,1].

## System metrics definition

The **system_metrics** section is used by the use case and simulator provider to
specify the names, the types and the units of the system metrics that can be
estimated by the simulator:

    <system_metrics>
    	<system_metric name="cycles" type="integer" unit="cycles" desired="small"/>
    	<system_metric name="instructions" type="integer" unit="insts" description="..."/>
    	<system_metric name="powerconsumption" type="float" unit="W" description="..." />
    	<system_metric name="area" type="float" unit="mm2" desired="small" />
    </system_metrics >

Feasible system metric "name" attributes are identified by the following regular
expression:

    [A-Za-z_] [A-Za-z0-9_]*

The optional "description" attribute is a generic string describing the nature
of the system metric. The "desired" attribute indicates whether it is desirable
to have a "small"/"big" value of a specific system metric. This attribute is
optional and may be taken into account by **MOST** in the formalization of the
optimization problem which, however, it is not part of this specification.
**MOST** expects to find the system metrics defined in this section in the
output file of the simulator. The output file name of the simulator is the
second argument passed to the simulator executable file.

**[R1.5]**. A **repeat** attribute can be used to specify the number of
scenarios for which the metrics have to be gathered. For example:
<system_metrics repeat="3"> <system_metric name="cycles" type="integer"
unit="cycles" desired="small"/> <system_metric name="instructions"
type="integer" unit="insts" description="..."/> </system_metrics >

Will actually instantiate the following metrics: <system_metrics >
<system_metric name="cycles_0" type="integer" unit="cycles" desired="small"/>
<system_metric name="instructions_0" type="integer" unit="insts"
description="..."/> <system_metric name="cycles_1" type="integer" unit="cycles"
desired="small"/> <system_metric name="instructions_1" type="integer"
unit="insts" description="..."/> <system_metric name="cycles_2" type="integer"
unit="cycles" desired="small"/> <system_metric name="instructions_2"
type="integer" unit="insts" description="..."/> </system_metrics >

## Feasibility rules

The **rules** section is used by **MOST** in order to not generate invalid or
not feasible solutions during the automated exploration process. The behavior of
the simulator when these rules are not met is undefined. Each rule is a boolean
expression which should evaluate to true for a feasible configuration of the
design space. It is up to **MOST** tool to check for the rules and generate
feasible configurations. Each boolean expression can be an operator acting on
either a **parameter** or **constant** leafs or other boolean expressions. This
allows creating complex expression trees of rules. Rules are ”AND”ed by default
by **MOST**. Each rule is identified by a **rule** marker and it has an optional
”name” attribute. As an example:

    <rules>
    	<rule>
    		<greater-equal>
    			<parameter name="l2_cache_block_size"/>
    			<parameter name="l1_dcache_block_size"/>
    		</greater-equal>
    	</rule>
    	<rule name="application-derived minimal size" >
    		<greater-equal>
    			<parameter name="l2_cache_size"/>
    			<constant value="2048"/>
    		</greater-equal>
    	</rule>
    </rules>

describes: (l2_cache_block_size >= l1_dcache_block_size) AND
(l2_cache_size >= 2048)

**Available operators**. The following operators/markers can be used:

    <greater>, <greater-equal>, <less>, <less-equal>, <equal>, <not-equal>, <expr>

The **expr** marker can be used for introducing generic expressions e.g.:

    <rule>
    	<greater-equal>
    		<parameter name="l2_cache_size"/>
    			<expr operator="*">
    				<constant value="2"/>
    				<parameter name="l1_cache_size"/>
    			</expr>
    		</greater-equal>
    </rule>

The previous set of rules is represents (l2_cache_size >= 2*l1_cache_size). The
operators supported by **MOST** are {+ - * / }.

For combining complex expressions, boolean **or, and, not** markers can be used
(e.g.):

    <rules>
    	<rule name="overall memory subsystem integrity">
    	<and>
    		<greater-equal>
    			<parameter name="l2_cache_block_size"/>
    			<parameter name="l1_dcache_block_size"/>
    		</greater-equal>
    		<greater-equal>
    			<parameter name="l2_cache_size"/>
    			<constant value="2048"/>
    		</greater-equal>
    	</and>
    	</rule>
    </rules>

**If-then-else rule**. An "if(E) then A" predicate is introduced and it is
evaluated as:

- TRUE if E is FALSE
- A if E is TRUE

An example for this rule is the following:

    <rule name="branch prediction design space reduction">
    	<if>
    		<not-equal>
    			<parameter name="bpred"/>
    			<constant value="bimod"/>
    		</not-equal>
    		<then>
    			<equal>
    				<parameter name="bpred_bmod_size"/>
    				<constant value="0"/>
    			</equal>
    		</then>
    	</if>
    </rule>

which represents: if(bpred!=bmod) then bpred_bmod_size=0

This rule forces to generate configurations where if bpred!=bmod then
bpred_bmod_size=0. These rules can effectively reduce the overall design space.
An "if(E) then A else B" predicate is introduced and it is evaluated as:

- B if E is FALSE
- A if E is TRUE

# MOST XML Input/Output Interface

The **MOST**/Simulator interface is composed of 2 files one in output from
**MOST** to the simulator the other one in the opposite direction.

## Simulator input file

The simulator input file should contain a preamble and a sequence of
**parameter** sections where, for each parameter, the name and the value is
specified:

    <?xml version=”1.0” encoding=”UTF-8”?>
    <simulator_input_interface xmlns=”http://www.multicube.eu/” version=”1.4”>
    	<parameter name=”seed” value=”1” />
    	...
    	</simulator_input_interface >

The number of **parameter** sections and the name of the parameters should be
the same as defined in the XML Design Space description file. The value of the
each parameter section should correspond to one of the possible values as
defined in the XML Design Space description file. Concerning variable vector
parameters, the actual parameter instances are specified with an itemized list.
For example, an on_off_mask instance value for the ”active_processors” parameter
is described in the simulator input file as the following list:

    <parameter name="active_processors" >
    	<item index="1" value="0" />
    	<item index="2" value="1" />
    	<item index="3" value="0" />
    	<item index="4" value="1" />
    </parameter>

In the case of a permutation vector, the index attribute is substituted with the
position attribute:

    <parameter name="thread_assignment" >
    	<item position="1" value="2" />
    	<item position="2" value="3" />
    	<item position="3" value="1" />
    </parameter>

Index and position attributes start from 1 up to the dimension associated to the
variable vector.

## Simulator Output File

The simulator output file contains a preamble and a sequence of
**system_metric** sections where, for each metric, the name and the value is
specified:

    <?xml version="1.0" encoding="UTF-8"?>
    <simulator_output_interface xmlns="http://www.multicube.eu/" version="1.4">
    	<system_metric name="cycles" value="3000" />
    	<system_metric name="instructions" value="1500" />
    	<system_metric name="power\_consumption" value="2.5" />
    	<system_metric name="area" value="25" />
    </simulator_output_interface>

The number of **system_metric** sections and the name of the system metrics
should be the same as defined in the XML Design Space description file.

In the case of errors during the simulator execution, the simulator output file
should contain a single **error** marker indicating the error reason:

    <?xml version="1.0" encoding="UTF-8"?>
    <simulator_output_interface xmlns="http://www.multicube.eu/" version="1.4">
    	<error reason="memory-full" kind="fatal"/>
    </simulator_output_interface>

The attribute reason is a generic string that can contain a report about the
error cause. Overall, the error strings of the simulator are meant to be related
to:

- memory-full or disk-full problems
- file system permissions problems.
- license problems.
- internal exceptions.
- consistency or feasibility violation (if checked by the simulator)
- timeout violation

The kind can be "fatal"/"non-fatal". Fatal errors should block the overall
exploration process while non-fatal errors force **MOST** to skip to the next
configuration. If an **error** marker is present in the output file,
**system_metric** markers are ignored by **MOST**.
